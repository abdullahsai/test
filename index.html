<!DOCTYPE html>
<html>
  <head>
    <base target="_top">
    <meta charset="utf-8">
    <title>Text Logger</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 2rem auto;
        max-width: 480px;
        line-height: 1.5;
      }

      #entries {
        margin-top: 1.5rem;
        padding: 0;
        list-style: none;
        border-top: 1px solid #ddd;
      }

      #entries li {
        padding: 0.5rem 0;
        border-bottom: 1px solid #f0f0f0;
        word-break: break-word;
      }

      #entries li.entry--pending {
        opacity: 0.65;
      }

      #entries li .entry__error {
        color: #b00020;
        font-size: 0.875rem;
        margin-top: 0.25rem;
        display: block;
      }

      button {
        margin-left: 0.5rem;
        padding: 0.5rem 1rem;
      }
    </style>
  </head>
  <body>
    <h1>Text Logger</h1>
    <div>
      <label for="textInput" class="sr-only">Text entry</label>
      <input id="textInput" type="text" placeholder="Type something" />
      <button id="saveButton" type="button">Save</button>
    </div>
    <ul id="entries" aria-live="polite"></ul>
    <script>
      (function () {
        var input = document.getElementById('textInput');
        var button = document.getElementById('saveButton');
        var list = document.getElementById('entries');

        function createEntryItem(text) {
          var item = document.createElement('li');
          var textSpan = document.createElement('span');
          textSpan.className = 'entry__text';
          textSpan.textContent = text;
          item.appendChild(textSpan);
          return item;
        }

        function renderEntries(entries) {
          list.innerHTML = '';
          entries.forEach(function (text) {
            list.appendChild(createEntryItem(text));
          });
        }

        function appendPendingEntry(text) {
          var item = createEntryItem(text);
          item.classList.add('entry--pending');
          list.appendChild(item);
          return item;
        }

        function showSaveError(item, error) {
          item.classList.remove('entry--pending');
          var message = 'Failed to save, please retry.';
          var errorNode = item.querySelector('.entry__error');
          if (!errorNode) {
            errorNode = document.createElement('span');
            errorNode.className = 'entry__error';
            item.appendChild(errorNode);
          }
          errorNode.textContent = message;
          console.error('Failed to save text:', error);
        }

        function handleError(error) {
          console.error('Error loading entries:', error);
        }

        var fallbackRun = {
          _entries: [],
          _shouldFailNext: false,
          successHandler: null,
          failureHandler: null,
          withSuccessHandler: function (cb) {
            this.successHandler = cb;
            return this;
          },
          withFailureHandler: function (cb) {
            this.failureHandler = cb;
            return this;
          },
          _triggerSuccess: function (payload) {
            if (this.successHandler) {
              this.successHandler(payload);
            }
          },
          _triggerFailure: function (error) {
            if (this.failureHandler) {
              this.failureHandler(error);
            }
          },
          saveText: function (text) {
            var self = this;
            setTimeout(function () {
              if (self._shouldFailNext) {
                self._shouldFailNext = false;
                self._triggerFailure(new Error('Simulated save failure'));
                return;
              }
              self._entries.push(text);
              self._triggerSuccess(self._entries.slice());
            }, 0);
            return this;
          },
          getEntries: function () {
            var self = this;
            setTimeout(function () {
              self._triggerSuccess(self._entries.slice());
            }, 0);
            return this;
          },
          failNextSave: function () {
            this._shouldFailNext = true;
          },
          reset: function () {
            this._entries = [];
            this._shouldFailNext = false;
            this.successHandler = null;
            this.failureHandler = null;
          },
        };

        var scriptRun =
          typeof google !== 'undefined' && google.script && google.script.run
            ? google.script.run
            : fallbackRun;

        if (typeof window !== 'undefined') {
          window.__textLogger__ = {
            renderEntries: renderEntries,
            handleError: handleError,
            scriptRun: scriptRun,
            fallbackRun: fallbackRun,
            appendPendingEntry: appendPendingEntry,
            showSaveError: showSaveError,
          };
        }

        button.addEventListener('click', function () {
          var value = input.value.trim();
          if (!value) {
            input.focus();
            return;
          }
          var pendingItem = appendPendingEntry(value);
          scriptRun
            .withSuccessHandler(function (entries) {
              renderEntries(entries);
            })
            .withFailureHandler(function (error) {
              showSaveError(pendingItem, error);
            })
            .saveText(value);
          input.value = '';
          input.focus();
        });

        scriptRun
          .withSuccessHandler(renderEntries)
          .withFailureHandler(handleError)
          .getEntries();
      })();
    </script>
  </body>
</html>
